# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/04 training.transcription.sampling.ipynb.

# %% auto 0
__all__ = ['sample_intron_edges', 'sample_introns', 'sample_mrna', 'sample_mrna_edges', 'sample_sequences_idx',
           'get_training_sequences_with_idx', 'tokenize_gene', 'tokenize_mrna', 'get_gene_transcript_samples',
           'get_gene_transcript_samples_wrapper', 'get_multiple_training_sequences_wrapper', 'create_genes_index',
           'create_mrna_index']

# %% ../../../nbs/04 training.transcription.sampling.ipynb 5
from pathlib import Path
import numpy as np
import pandas as pd
from pandas.errors import SettingWithCopyWarning
import random
import warnings
from tqdm import tqdm
from multiprocessing import current_process
import sqlite3

warnings.filterwarnings("ignore", category=SettingWithCopyWarning)

from ...data.download import load_config, \
    get_latest_assembly_path, get_genomic_genbank_path
from ...data.transcription import get_genes
from .index import get_intron_locations
from .generation import get_mrna_locations, get_mrna

# %% ../../../nbs/04 training.transcription.sampling.ipynb 16
def sample_intron_edges(
        locations: pd.DataFrame, n: int, 
        random_state: int = 42, offset: int = -32, length: int = 64) -> pd.DataFrame:
    "Get training instances where either the start of end of an intron is in the center of the sequence."
    start_n = int(n / 2)
    end_n = n - start_n
    replace = True if (start_n > locations.shape[0]) | (end_n > locations.shape[0]) else False
    starts = locations.sample(start_n, replace=replace, random_state=random_state)
    ends = locations.sample(end_n, replace=replace, random_state=random_state)
    frames = []
    for f, slice_origin in zip([starts, ends], ['intron_start', 'intron_end']):
        f_slice_start = (f[slice_origin] - f.mrna_start + offset).apply(lambda val: max(0, val))
        f.loc[:, 'mrna_len'] = f.mrna_end - f.mrna_start
        f.loc[:, 'start'] = f_slice_start
        f.loc[:, 'end'] = (f_slice_start + length)
        f.loc[:, 'end'] = f[['end', 'mrna_len']].min(axis=1)
        # Detect short sequences
        short_mask = (f.end - f.start) != length
        short_end_mask = short_mask & (f.end == f.mrna_len)
        short_start_mask = short_mask & (f.start == 0)
        if short_end_mask.sum() > 0:
            # Fix the samples with short ends
            f_short_ends = f.loc[short_end_mask, :]
            f_short_lengths = f_short_ends.end - f_short_ends.start
            f_short_adjustments = f_short_lengths - length
            f_short_ends.loc[:, 'start'] = f_short_ends.start + f_short_adjustments
            f.loc[short_end_mask, :] = f_short_ends
        if short_start_mask.sum() > 0:
            # Fix the samples with short starts
            f_short_starts = f.loc[short_start_mask, :]
            f_short_lengths = f_short_starts.end - f_short_starts.start
            f_short_adjustments = (f_short_lengths - length).mul(-1)
            f_short_starts.loc[:, 'end'] = f_short_starts.end + f_short_adjustments
            f.loc[short_start_mask, :] = f_short_starts
        f = f[['chromosome', 'geneid', 'transcriptid', 'start', 'end']]
        frames.append(f)
    intron_edges = pd.concat(frames, axis=0)
    intron_edges.loc[:, 'type'] = 'intron-edge'
    return intron_edges

# %% ../../../nbs/04 training.transcription.sampling.ipynb 22
def sample_introns(
        locations: pd.DataFrame, n: int,
        random_state: int = 42, length: int = 64) -> pd.DataFrame:
    random.seed(random_state)
    "Get training instances where most of the tokens are <intron>."
    replace = False if n < locations.shape[0] else True
    intron_sample = locations.sample(n, replace=replace, random_state=random_state)
    # Handle sequences of varying sizes
    intron_sample.loc[:, 'intron_length'] = intron_sample.intron_end - intron_sample.intron_start
    intron_len_mask = intron_sample.intron_length <= length
    small_introns = intron_sample[intron_len_mask]
    large_introns = intron_sample[~intron_len_mask]
    sample_frames = []
    if small_introns.shape[0] > 0:
        # For those introns less than length, center, return the whole thing
        # Start at intron start
        small_intron_slice_center = small_introns.intron_start
        # Shift slice center half the distance of the target sequence
        small_intron_slice_center = small_intron_slice_center.subtract(int(length / 2)).apply(lambda val: max(0, val))
        small_introns.loc[:, 'start'] = small_intron_slice_center
        small_introns.loc[:, 'end'] = small_introns.start + length
        small_introns.loc[:, 'end'] = small_introns[['end', 'mrna_end']].min(axis=1)
        small_introns = small_introns[['chromosome', 'geneid', 'transcriptid', 'start', 'end']]
        small_introns.loc[:, 'type'] = 'intron-small'
        sample_frames.append(small_introns)
    if large_introns.shape[0] > 0:
        # For larger introns, identify the range we can slice to avoid edges
        large_introns.loc[:, 'slice_max'] = large_introns.intron_end - length
        large_introns.loc[:, 'slice_range'] = large_introns.apply(lambda row: range(row.intron_start, row.slice_max + 1, 1), axis=1)
        large_introns.loc[:, 'start'] = large_introns.slice_range.apply(lambda r: random.choice(r))
        large_introns.loc[:, 'end'] = large_introns.start + length
        large_introns = large_introns[['chromosome', 'geneid', 'transcriptid', 'start', 'end']]
        large_introns.loc[:, 'type'] = 'intron'
        sample_frames.append(large_introns)
    # Randomly select a slice point within the identified range
    introns = pd.concat(sample_frames, axis=0)
    return introns

# %% ../../../nbs/04 training.transcription.sampling.ipynb 27
def sample_mrna(
        mrna_locations: pd.DataFrame, n: int, 
        random_state: int = 42, length: int = 64) -> pd.DataFrame:
    "Get a sample or mrna sequence locations"
    replace = False if n < mrna_locations.shape[0] else True
    mrna_locations = mrna_locations.sample(n, replace=replace, random_state=random_state)
    # For small mrna sections, do the same thing we did with the introns
    # Handle sequences of varying sizes
    mrna_locations.loc[:, 'length'] = mrna_locations.end - mrna_locations.start
    mrna_len_mask = mrna_locations.length <= length
    small_sequences = mrna_locations[mrna_len_mask]
    large_sequences = mrna_locations[~mrna_len_mask]
    sample_frames = []
    if small_sequences.shape[0] > 0:
        # For those introns less than length, center, return the whole thing
        # Start at intron start
        small_sequences_slice_center = small_sequences.start
        # Shift slice center half the distance of the target sequence
        small_sequences_slice_center = small_sequences_slice_center.subtract(int(length / 2)).apply(lambda val: max(0, val))
        small_sequences.loc[:, 'start'] = small_sequences_slice_center
        small_sequences.loc[:, 'end'] = small_sequences.start + length
        small_sequences.loc[:, 'end'] = small_sequences[['end', 'mrna_end']].min(axis=1)
        small_sequences = small_sequences[['chromosome', 'geneid', 'transcriptid', 'start', 'end']]
        small_sequences.loc[:, 'type'] = 'mrna-small'
        sample_frames.append(small_sequences)
    if large_sequences.shape[0] > 0:
        # For larger introns, identify the range we can slice to avoid edges
        large_sequences.loc[:, 'slice_max'] = large_sequences.end - length
        large_sequences.loc[:, 'slice_range'] = large_sequences.apply(lambda row: range(row.start, row.slice_max + 1, 1), axis=1)
        large_sequences.loc[:, 'start'] = large_sequences.slice_range.apply(lambda r: random.choice(r))
        large_sequences.loc[:, 'end'] = large_sequences.start + length
        large_sequences = large_sequences[['chromosome', 'geneid', 'transcriptid', 'start', 'end']]
        large_sequences.loc[:, 'type'] = 'mrna'
        sample_frames.append(large_sequences)
    # Randomly select a slice point within the identified range
    return pd.concat(sample_frames, axis=0, ignore_index=True)

# %% ../../../nbs/04 training.transcription.sampling.ipynb 30
def sample_mrna_edges(locations: pd.DataFrame, n: int, random_state: int = 42, length: int = 64) -> pd.DataFrame:
    "Get the beginning and end of mrna"
    locations = locations.drop_duplicates(
        ['chromosome', 'geneid', 'transcriptid', 'mrna_start', 'mrna_end']
    ).drop(['intron_start', 'intron_end'], axis=1).reset_index(drop=True)
    n_start = int(n / 2)
    n_end = n - n_start
    replace = False if (n_start < locations.shape[0]) or (n_end < locations.shape[0]) else True
    mrna_starts = locations.sample(
        n_start, replace=replace, random_state=random_state
        ).rename({'mrna_start': 'start'}, axis=1)
    mrna_starts.loc[:, 'end'] = mrna_starts.start + length
    mrna_starts.loc[:, 'end'] = mrna_starts[['mrna_end', 'end']].min(axis=1)
    mrna_starts.drop(['mrna_end'], axis=1, inplace=True)
    mrna_ends = locations.sample(
        n_end, replace=replace, random_state=random_state).rename({'mrna_end': 'end'}, axis=1)
    mrna_ends.loc[:, 'start'] = mrna_ends.end - length
    mrna_ends.loc[:, 'start'] = mrna_ends[['mrna_start', 'start']].max(axis=1)
    mrna_ends.drop(['mrna_start'], axis=1, inplace=True)
    sample_edges = pd.concat([mrna_starts, mrna_ends], axis=0, ignore_index=True)
    sample_edges = sample_edges[['chromosome', 'geneid', 'transcriptid', 'start', 'end']]
    sample_edges.loc[:, 'type'] = 'mrna-edge'
    return sample_edges

# %% ../../../nbs/04 training.transcription.sampling.ipynb 32
def sample_sequences_idx(
        n: int, 
        intron_locations: pd.DataFrame,
        mrna_locations: pd.DataFrame,
        intron_prop: float, intron_edge_prop: float, 
        mrna_prop: float, mrna_edge_prop: float,
        random_state: int = 42,
        length: int = 64) -> pd.DataFrame:
    "Build training dataset from intron locations."
    intron_sample = sample_introns(
        intron_locations, int(n * intron_prop), 
        random_state=random_state, length=length)
    intron_edge_sample = sample_intron_edges(
        intron_locations, int(n * intron_edge_prop), 
        random_state=random_state, length=length)
    mrna_sample = sample_mrna(mrna_locations, int(n * mrna_prop), 
        random_state=random_state, length=length)
    mrna_edge_sample = sample_mrna_edges(intron_locations, int(n * mrna_edge_prop),
        random_state=random_state, length=length)
    sample = pd.concat([
        intron_sample,
        intron_edge_sample,
        mrna_sample,
        mrna_edge_sample
    ], axis=0, ignore_index=True)
    return sample

# %% ../../../nbs/04 training.transcription.sampling.ipynb 36
def get_training_sequences_with_idx(
        gene: list[str], mrna: list[str],
        start: int, end: int,
        ) -> tuple[str, str]:
    ""
    return ",".join(gene[start: end]), ",".join(mrna[start: end])

# %% ../../../nbs/04 training.transcription.sampling.ipynb 38
def tokenize_gene(gene: str) -> list[str]:
    return list(gene)


def tokenize_mrna(mrna: str) -> list[str]:
    return mrna.split(',')

# %% ../../../nbs/04 training.transcription.sampling.ipynb 46
def get_gene_transcript_samples(
    chromosome: str,
    geneid: str,
    transcript_id: str,
    sample_idx: list[list[int, int]],
    assembly_path: Path,
    sep: str = ",",
    gene_connection: sqlite3.Connection | None = None,
    mrna_connection: sqlite3.Connection | None = None) -> list[tuple[int, str, str]]:
    gene_str_list = tokenize_gene(
        get_genes(
            assembly_path, chromosome=chromosome, 
            gene_ids=[geneid],
            con=gene_connection
        ).sequence.iloc[0])
    mrna_str_list = tokenize_mrna(
        get_mrna(
            assembly_path, chromosome=chromosome, 
            gene_ids=[geneid], transcript_ids=[transcript_id],
            con=mrna_connection).sequence.iloc[0])
    samples = []
    for start, end in sample_idx:
        samples.append(
            (
                sep.join(gene_str_list[start: end]),
                sep.join(mrna_str_list[start: end])
            )
        )
    return samples

# %% ../../../nbs/04 training.transcription.sampling.ipynb 52
def get_gene_transcript_samples_wrapper(args) -> pd.DataFrame:
    chromosome = args.get("chromosome")
    gene_id = args.get('geneid')
    transcript_id = args.get("transcriptid")
    sample_idx = args.get("index")
    index_types = args.get("types")
    assembly_path = args.get("assembly_path")
    sequences_list = get_gene_transcript_samples(
        chromosome,
        gene_id,
        transcript_id,
        sample_idx,
        assembly_path
    )
    sequences_frame = pd.DataFrame(
        sequences_list, columns=['input', 'target'])
    sequences_frame.loc[:, 'chromosome'] = chromosome
    sequences_frame.loc[:, 'geneid'] = gene_id
    sequences_frame.loc[:, 'transcriptid'] = transcript_id
    sequences_frame.loc[:, 'type'] = index_types
    idx_df = pd.DataFrame(sample_idx, columns=['start', 'end'])
    sequences_frame = pd.concat([sequences_frame, idx_df], axis=1)
    return sequences_frame

# %% ../../../nbs/04 training.transcription.sampling.ipynb 56
def get_multiple_training_sequences_wrapper(args: dict):
    "Receive a chunk of training indices, batch process them and write to disc."
    process_idx = next(iter(current_process()._identity), 0)
    index = args.get("index")
    assembly_path = args.get("assembly_path")
    epoch = args.get("epoch")
    chunk_size = args.get("chunk_size", 50)
    batch_size = args.get("batch_size", 10000)
    save = args.get("save", True)
    # Make sqlite3 connections
    genes_connection = sqlite3.connect(assembly_path / "genes.db")
    mrna_connection = sqlite3.connect(assembly_path / "mrna.db")
    write_path = assembly_path / "training/transcription/sequences" / f"epoch-{epoch}"
    if not write_path.exists():
        write_path.mkdir()
    # Split up index to chunks
    num_chunks = max(1, int(index.shape[0] / chunk_size))
    index = np.array_split(index, num_chunks)
    # Process chunks
    batch = []
    batch_row_counter = 0
    batch_counter = 1
    pbar = tqdm(
        total=len(index), ncols=80, 
        desc=f"Process-{process_idx}-Generating", 
        position=process_idx)
    try:
        for chunk in index:
            # Get input, target sequences
            sequences = chunk.apply(
                lambda row: get_gene_transcript_samples(
                    row.chromosome,
                    row.geneid,
                    row.transcriptid,
                    row.idx,
                    assembly_path
                ), 
                axis=1)
            # Put into dataframe
            sequences = pd.concat(
                sequences.apply(
                    pd.DataFrame, columns=['input', 'target']
                ).values.tolist(), 
                axis=0)
            batch.append(sequences)
            batch_row_counter += sequences.shape[0]
            pbar.update(1)
            if (batch_row_counter >= batch_size) and save:
                pbar.set_description(f"Process-{process_idx}-Writing")
                # Write batch
                batch = pd.concat(batch, axis=0, ignore_index=True)
                batch_write_path = write_path / f"batch-{batch_counter}"
                batch.to_parquet(batch_write_path, index=False)
                batch = []
                batch_row_counter = 0
                batch_counter += 1
                pbar.set_description(f"Process-{process_idx}-Generating")
        # Write final batch
        if (len(batch) > 0) and save:
            pbar.set_description(f"Process-{process_idx}-Writing")
            batch = pd.concat(batch, axis=0, ignore_index=True)
            batch_write_path = write_path / f"batch-{batch_counter}"
            batch.to_parquet(batch_write_path, index=False)
    except Exception as e:
        raise e
    finally:
        genes_connection.close()
        mrna_connection.close()
        pbar.close()

# %% ../../../nbs/04 training.transcription.sampling.ipynb 59
def create_genes_index(assembly_path):
    con = sqlite3.connect(assembly_path / "genes.db")
    con.execute("CREATE UNIQUE INDEX IF NOT EXISTS genes_index ON genes(chromosome, geneid);")
    con.close()


def create_mrna_index(assembly_path):
    con = sqlite3.connect(assembly_path / "mrna.db")
    con.execute("CREATE UNIQUE INDEX IF NOT EXISTS mrna_index ON mrna(chromosome, geneid, transcriptid);")
    con.close()
